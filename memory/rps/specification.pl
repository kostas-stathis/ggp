/*
	Rock-paper-scissors specification
	author: Kostas Stathis
	created: 5/3/24
	last update: 5/3/24
*/

/* Game independent description */

% All legal evolutions of a game: can be used both as a generator and test.
game(F,F):- final(F). 
game(S,F):-
        \+ final(S),
        legal(M,S), %once((count(S,C),write(C:M), nl)),
        game(do(M,S),F).

% Situation Calculus - our formulation for games.
holds(F, S):- initially(F, S).
holds(F, do(M, S)):- effect(F, M, S).
holds(F, do(A, S)):- holds(F, S), \+ abnormal(F, A, S).



/* Game dependent predicates                 
 -----------------------------------------------
 Representation assumes single game states 
 as Prolog terms. The term

	rps(P,O,Mp,Mo,Up,Uo)

 contains the player P, opponent O, move of P
 is Mp, move of opponent O is Mo, and Up, Uo
 are the player's amd the opponents utilities.

 No need to introduce initial states, or ids,
 as we assume that we do not have to play multiple
 games at once. 

 Effects and results are achieved via unification.
 ------------------------------------------------- 
*/

% ~20 lines of Prolog

:- discontiguous initially/2.
:- discontiguous payoffRPS/4.
:- discontiguous final/1.
:- discontiguous legal/2.
:- discontiguous possible/2.
:- discontiguous effect/3.
:- discontiguous abnormal/3.
:- discontiguous finally/2.
:- discontiguous finally/1.

/* Game specific predicates for Rock-Paper-Scissors (RPS) */

% Payoff matrix for RPS
payoffRPS('rock', 'rock', 0, 0).
payoffRPS('rock', 'paper', 0, 1).
payoffRPS('rock', 'scissors', 1, 0).
payoffRPS('paper', 'rock', 1, 0).
payoffRPS('paper', 'paper', 0, 0).
payoffRPS('paper', 'scissors', 0, 1).
payoffRPS('scissors', 'rock', 0, 1).
payoffRPS('scissors', 'paper', 1, 0).
payoffRPS('scissors', 'scissors', 0, 0).

% Initial state
initial(s0).

% What holds initially: who is a player, their role, and whether they can play.	
initially(player(p1), s0).
initially(player(p2), s0).
initially(role(p1, row), s0).
initially(role(p2, col), s0).
initially(control(p1), s0).
initially(control(p2), s0).

% When a state is final: no need to check content as it generated by game/2,
% implying it is a legal state.
final(do(choice(_P2, _M2), do(choice(_P1, _M1), S))) :- initial(S).

% A legal move is a possible move where the player has control (is its turn).
legal(choice(P, M), S) :- possible(choice(P, M), S), holds(control(P), S).

% What is possible for a player to choose
possible(choice(P, 'rock'), S) :- holds(player(P), S).
possible(choice(P, 'paper'), S) :- holds(player(P), S).
possible(choice(P, 'scissors'), S) :- holds(player(P), S).

% The effects of a move: if P has chosen M, then in the next state this
% is what they did.
effect(did(P, M), choice(P, M), _S).

% The effects of a move: once a choice is made, the player loses control, i.e.
% cannot move anymore.
abnormal(control(P), choice(P, _M), _S).

% What holds finally: the outcome with players, Moves, and Utilities.
finally(outcome(P1, M1, U1, P2, M2, U2), S) :-
    final(S),
    holds(role(P1, row), S),	
    holds(did(P1, M1), S),	
    holds(role(P2, col), S),	
    holds(did(P2, M2), S),
    payoffRPS(M1, M2, U1, U2).

% Goals achieved by the players.
finally(goal(P1, U1), S) :-
    finally(outcome(P1, _, U1, _, _, _), S).
finally(goal(P2, U2), S) :-
    finally(outcome(_, _, _, P2, _, U2), S).
