
/*
	Game description framework 
	author: Kostas Stathis
	SWI-Prolog version
	Last update: 12/05/2024
*/

/* Game independent description */

% All legal evolutions of a game: can be used both as a generator and test.
game(F,F):- final(F).  
game(S,F):- \+ final(S), legal(M,S), game(do(M,S),F).

% Situation Calculus - our formulation for games.
holds(F, S):- initially(F, S).
holds(F, do(M, S)):- effect(F, M, S).
holds(F, do(A, S)):- holds(F, S), \+ abnormal(F, A, S).

finally(F, S):- final(S), holds(F, S).

% Initial state
initial(s0).

% What holds initially: who is a player, their role, and whether they can play.	
initially(player(p1), s0).
initially(player(p2), s0).
initially(control(p1), s0).
initially(control(p2), s0).
initially(range(0,100), s0).
initially(multiplier(0.666), s0).


% When a state is final: no need to check content as it generated by game/2,
% implying it is a legal state.
final(S, S):-
	ground(S),
	\+ holds(control(_), S).

% A legal move is a possible move where the player has control (is its turn).
legal(move(P, M), S):- possible(move(P, M), S), holds(control(P), S).

% What is possible for a player to choose
possible(move(P, No), S):- 
	holds(player(P), S), 
	holds(range(L,U), S),
	between(L, U, No).

% The effects of a move: if P has chosen M, then in the next state this
% is what they did.
effect(did(P, M), move(P, M), _S).

% The effects of a move: once a choice is made, the player looses control, i.e.
% cannot move anymore.

abnormal(control(P), move(P, _M), _S).

% What holds finally: the outcome with players, Moves, and Utilities.
holds(goal(P, D), S):-
	holds(did(P, M), S),	
	average(S, Average),
	holds(multiplier(M), S),
	Target is M * Average,
	distance(Target, M, D).


% Library predicates
% Calculate the distance between the target and the move made.
distance(Target, M, D):-
	(  Target > M
	-> D is Target - M
	;  D is M - Target
	).

% Convert the situation to a list of moves made by players.
moves_to_list(S, []):- 
	atomic(S)!.
moves_to_list(do(move(_,M), S), [M|Moves]):- 
	moves_to_list(S, Moves).

% Calculate the average of the moves made in a situation.
average(S, Average):-
	moves_to_list(S, Moves),
	avg(Moves, Average).

% Calculate the average of a list of numbers.
avg( List, Avg ):- 
    sum( List, Sum ),
    length( List, Length), 
    (  Length > 0
    -> Avg is Sum / Length
    ;  write('List is empty, cannot compute average'), nl, fail
    ).

% Calculate the sum of a list of numbers.
sum( [], 0 ).
sum( [H|T], Sum ):- 
	sum( T, TailSum ),
	Sum is H + TailSum.